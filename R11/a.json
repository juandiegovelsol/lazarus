{
  "programming_language": ["javascript", "html"],
  "install_commands": [],
  "run_commands": "node main.js",
  "output": "",
  "output_expected": "no",
  "output_mime_type": "text/plain",
  "stream_source": "stdout",
  "code": [
    {
      "name": "index.js",
      "content": "const canvas = document.getElementById('simulationCanvas');\r\nconst ctx = canvas.getContext('2d');\r\n\r\nconst balls = [];\r\nconst barriers = [];\r\n\r\nconst gravity = 0.1; \r\nconst friction = 0.99;\r\nconst restitution = 0.8;\r\nconst windSpeed = 3; // m/s\r\nconst maxBounces = 5;\r\n\r\nconst MAX_RADIUS = 10;\r\n\r\nclass Ball {\r\n    constructor(x, y, radius, color) {\r\n        Object.assign(this, { x, y, radius, color });\r\n        this.dx = (Math.random() - 0.5) * 2;\r\n        this.dy = 0;\r\n        this.bounces = 0;\r\n    }\r\n\r\n    draw() {\r\n        ctx.beginPath();\r\n        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);\r\n        ctx.fillStyle = this.color;\r\n        ctx.fill();\r\n        ctx.closePath();\r\n    }\r\n\r\n    update() {\r\n        this.dx += (Math.random() - 0.5) * 0.01 - windSpeed / 100; // Simulate wind\r\n        this.dy += gravity; \r\n\r\n        this.x += this.dx;\r\n        this.y += this.dy;\r\n\r\n        if (this.x + this.radius > canvas.width) {\r\n            this.x = canvas.width - this.radius;\r\n            this.dx = -this.dx * restitution;\r\n            this.bounces++;\r\n        }\r\n\r\n        if (this.x - this.radius < 0) {\r\n            this.x = this.radius;\r\n            this.dx = -this.dx * restitution;\r\n            this.bounces++;\r\n        }\r\n\r\n        if (this.y - this.radius < 0) {\r\n            this.y = this.radius;\r\n            this.dy = -this.dy * restitution;\r\n            this.bounces++;\r\n        }\r\n\r\n        if (this.y + this.radius > canvas.height) {\r\n            this.y = canvas.height - this.radius;\r\n            this.dy = -this.dy * restitution;\r\n            this.bounces++;\r\n        }\r\n\r\n        if (this.bounces > maxBounces) {\r\n            const index = balls.indexOf(this);\r\n            if (index !== -1) {\r\n                balls.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        barriers.forEach(barrier => {\r\n            const { normalX, normalY, isColliding, contactPoint } = barrier.checkCollision(this.x, this.y, this.radius);\r\n            if (isColliding) {\r\n                const dotProduct = this.dx * normalX + this.dy * normalY;\r\n                this.dx -= 2 * dotProduct * normalX;\r\n                this.dy -= 2 * dotProduct * normalY;\r\n                this.dx *= restitution;\r\n                this.dy *= restitution;\r\n\r\n                // Apply friction\r\n                const tangentX = -normalY;\r\n                const tangentY = normalX;\r\n                const tangentVel = this.dx * tangentX + this.dy * tangentY;\r\n                this.dx -= tangentVel * tangentX * barrier.friction;\r\n                this.dy -= tangentVel * tangentY * barrier.friction;\r\n\r\n                // Rotate barrier\r\n                const impactForce = Math.sqrt(this.dx * this.dx + this.dy * this.dy);\r\n                barrier.applyTorque(impactForce, contactPoint);\r\n\r\n                this.color = getRandomColor();\r\n            }\r\n        });\r\n\r\n        balls.forEach(otherBall => {\r\n            if (otherBall !== this) {\r\n                const distance = Math.sqrt((this.x - otherBall.x) ** 2 + (this.y - otherBall.y) ** 2);\r\n                if (distance < this.radius + otherBall.radius) {\r\n                    const normalX = (this.x - otherBall.x) / distance;\r\n                    const normalY = (this.y - otherBall.y) / distance;\r\n                    const dotProduct = this.dx * normalX + this.dy * normalY;\r\n                    this.dx -= 2 * dotProduct * normalX;\r\n                    this.dy -= 2 * dotProduct * normalY;\r\n                    this.dx *= restitution;\r\n                    this.dy *= restitution;\r\n                }\r\n            }\r\n        });\r\n\r\n        this.draw();\r\n    }\r\n}\r\n\r\nclass Barrier {\r\n    constructor(x, y, width, height, angle, color) {\r\n        Object.assign(this, { x, y, width, height, angle, color });\r\n        this.angularVelocity = 0;\r\n        this.friction = 0.1;\r\n        this.momentOfInertia = (width * width + height * height) / 12;\r\n    }\r\n\r\n    draw() {\r\n        ctx.save();\r\n        ctx.translate(this.x + this.width / 2, this.y + this.height / 2);\r\n        ctx.rotate(this.angle * Math.PI / 180);\r\n        ctx.fillStyle = this.color;\r\n        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);\r\n        ctx.restore();\r\n    }\r\n\r\n    checkCollision(bx, by, br) {\r\n        const cos = Math.cos(-this.angle * Math.PI / 180);\r\n        const sin = Math.sin(-this.angle * Math.PI / 180);\r\n        const dx = bx - (this.x + this.width / 2);\r\n        const dy = by - (this.y + this.height / 2);\r\n        const localX = cos * dx - sin * dy + this.width / 2;\r\n        const localY = sin * dx + cos * dy + this.height / 2;\r\n\r\n        const closestX = Math.max(0, Math.min(this.width, localX));\r\n        const closestY = Math.max(0, Math.min(this.height, localY));\r\n\r\n        const distanceX = localX - closestX;\r\n        const distanceY = localY - closestY;\r\n        const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);\r\n\r\n        const isColliding = distance < br;\r\n        const normalX = distance !== 0 ? (cos * distanceX / distance + sin * distanceY / distance) : 0;\r\n        const normalY = distance !== 0 ? (-sin * distanceX / distance + cos * distanceY / distance) : 0;\r\n\r\n        const contactX = cos * closestX - sin * closestY + this.x;\r\n        const contactY = sin * closestX + cos * closestY + this.y;\r\n\r\n        return { normalX, normalY, isColliding, contactPoint: { x: contactX, y: contactY } };\r\n    }\r\n\r\n    applyTorque(force, contactPoint) {\r\n        const dx = contactPoint.x - (this.x + this.width / 2);\r\n        const dy = contactPoint.y - (this.y + this.height / 2);\r\n        const torque = force * (dx * Math.sin(this.angle * Math.PI / 180) - dy * Math.cos(this.angle * Math.PI / 180));\r\n        this.angularVelocity += torque / this.momentOfInertia;\r\n    }\r\n\r\n    update() {\r\n        this.angle += this.angularVelocity;\r\n        this.angularVelocity *= 0.98;\r\n    }\r\n}\r\n\r\nfunction getRandomColor() {\r\n    const letters = '0123456789ABCDEF';\r\n    let color = '#';\r\n    for (let i = 0; i < 6; i++) {\r\n        color += letters[Math.floor(Math.random() * 16)];\r\n    }\r\n    return color;\r\n}\r\n\r\nfor (let i = 0; i < 10; i++) {\r\n    const radius = MAX_RADIUS;\r\n    const x = Math.random() * (canvas.width - radius * 2) + radius;\r\n    const y = radius;\r\n    const color = 'blue';\r\n    balls.push(new Ball(x, y, radius, color));\r\n}\r\n\r\nbarriers.push(new Barrier(100, 500, 150, 20, -20, 'black'));\r\nbarriers.push(new Barrier(600, 400, 150, 20, -20, 'black'));\r\nbarriers.push(new Barrier(200, 200, 100, 20, 45, 'black'));\r\nbarriers.push(new Barrier(400, 150, 120, 20, -45, 'black'));\r\nbarriers.push(new Barrier(500, 500, 200, 20, 15, 'black'));\r\nbarriers.push(new Barrier(800, 300, 150, 20, -15, 'black'));\r\n\r\nfunction animate() {\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n    balls.forEach(ball => ball.update());\r\n    barriers.forEach(barrier => {\r\n        barrier.update();\r\n        barrier.draw();\r\n    });\r\n    requestAnimationFrame(animate);\r\n}\r\n\r\nanimate();"
    },
    {
      "name": "index.html",
      "content": "<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Ball Simulation</title>\r\n    <style>\r\n        body {\r\n            margin: 0;\r\n            overflow: hidden;\r\n        }\r\n        #simulationCanvas {\r\n            display: block;\r\n            background-color: #f0f0f0;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <canvas id=\"simulationCanvas\" width=\"1000\" height=\"600\"></canvas>\r\n    <script src=\"index.js\"></script>\r\n</body>\r\n</html>"
    }
  ]
}
