{
  "programming_language": ["javascript", "html"],
  "install_commands": [],
  "run_commands": "",
  "output": "",
  "output_expected": "no",
  "output_mime_type": "application/octet-stream",
  "stream_source": "stdout",
  "code": [
    {
      "name": "index.html",
      "content": "/**\n * Simulation of balls falling and interacting with rotating barriers.\n */\n\n// Get the canvas element\nconst canvas = document.getElementById('simulationCanvas');\nconst ctx = canvas.getContext('2d');\n\n// Constants\nconst GRAVITY = 0.1;\nconst FRICTION = 0.99;\nconst RESTITUTION = 0.8;\nconst MAX_RADIUS = 10;\nconst MAX_BOUNCES = 5;\nconst WIND_SPEED = 3; // 3 m/s\nconst WIND_ANGLE = 315 * Math.PI / 180; // 315 degrees in radians (NW direction)\n\n// Calculate wind force\nconst WIND_FORCE_X = WIND_SPEED * Math.cos(WIND_ANGLE) / 60; // Divide by 60 to convert m/s to pixels per frame\nconst WIND_FORCE_Y = -WIND_SPEED * Math.sin(WIND_ANGLE) / 60; // Negative because canvas Y is inverted\n\n// Arrays to hold balls and barriers\nconst balls = [];\nconst barriers = [];\n\n/**\n * Represents a ball in the simulation.\n */\nclass Ball {\n  /**\n   * Creates a new ball.\n   * @param {number} x - The x-coordinate of the ball.\n   * @param {number} y - The y-coordinate of the ball.\n   * @param {number} radius - The radius of the ball.\n   * @param {string} color - The color of the ball.\n   */\n  constructor(x, y, radius, color) {\n    this.x = x;\n    this.y = y;\n    this.radius = radius;\n    this.color = color;\n    this.dx = (Math.random() - 0.5) * 2;\n    this.dy = 0;\n    this.bounces = 0;\n  }\n\n  /**\n   * Draws the ball on the canvas.\n   */\n  draw() {\n    ctx.beginPath();\n    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);\n    ctx.fillStyle = this.color;\n    ctx.fill();\n    ctx.closePath();\n  }\n\n  /**\n   * Updates the ball's position and velocity.\n   */\n  update() {\n    this.dy += GRAVITY;\n    this.dy *= FRICTION;\n    this.dx *= FRICTION;\n\n    // Apply wind force\n    this.dx += WIND_FORCE_X;\n    this.dy += WIND_FORCE_Y;\n\n    this.x += this.dx;\n    this.y += this.dy;\n\n    // Check for collisions with the edge of the screen\n    if (this.x + this.radius > canvas.width) {\n      this.x = canvas.width - this.radius;\n      this.dx = -this.dx * RESTITUTION;\n      this.bounces++;\n    }\n\n    if (this.x - this.radius < 0) {\n      this.x = this.radius;\n      this.dx = -this.dx * RESTITUTION;\n      this.bounces++;\n    }\n\n    if (this.y - this.radius < 0) {\n      this.y = this.radius;\n      this.dy = -this.dy * RESTITUTION;\n    }\n\n    if (this.y + this.radius > canvas.height) {\n      this.y = canvas.height - this.radius;\n      this.dy = -this.dy * RESTITUTION;\n      this.bounces++;\n    }\n\n    // Check for collisions with barriers\n    barriers.forEach((barrier) => {\n      const {normalX, normalY, isColliding, contactPoint} = barrier.checkCollision(this.x, this.y, this.radius);\n      if (isColliding) {\n        const dotProduct = this.dx * normalX + this.dy * normalY;\n        this.dx -= 2 * dotProduct * normalX;\n        this.dy -= 2 * dotProduct * normalY;\n        this.dx *= RESTITUTION;\n        this.dy *= RESTITUTION;\n\n        const tangentX = -normalY;\n        const tangentY = normalX;\n        const tangentVel = this.dx * tangentX + this.dy * tangentY;\n        this.dx -= tangentVel * tangentX * barrier.friction;\n        this.dy -= tangentVel * tangentY * barrier.friction;\n\n        const impactForce = Math.sqrt(this.dx * this.dx + this.dy * this.dy);\n        barrier.applyTorque(impactForce, contactPoint);\n\n        this.color = getRandomColor();\n        this.bounces++;\n      }\n    });\n\n    // Check for collisions with other balls\n    balls.forEach((otherBall) => {\n      if (otherBall !== this) {\n        const distance = Math.sqrt((this.x - otherBall.x) ** 2 + (this.y - otherBall.y) ** 2);\n        if (distance < this.radius + otherBall.radius) {\n          const normalX = (this.x - otherBall.x) / distance;\n          const normalY = (this.y - otherBall.y) / distance;\n          const dotProduct = this.dx * normalX + this.dy * normalY;\n          this.dx -= 2 * dotProduct * normalX;\n          this.dy -= 2 * dotProduct * normalY;\n          this.dx *= RESTITUTION;\n          this.dy *= RESTITUTION;\n          this.color = getRandomColor();\n          this.bounces++;\n        }\n      }\n    });\n\n    // Remove the ball if it has bounced too many times\n    if (this.bounces >= MAX_BOUNCES) {\n      balls.splice(balls.indexOf(this), 1);\n    }\n\n    this.draw();\n  }\n}\n\n/**\n * Represents a barrier in the simulation.\n */\nclass Barrier {\n  /**\n   * Creates a new barrier.\n   * @param {number} x - The x-coordinate of the barrier.\n   * @param {number} y - The y-coordinate of the barrier.\n   * @param {number} width - The width of the barrier.\n   * @param {number} height - The height of the barrier.\n   * @param {number} angle - The angle of the barrier.\n   * @param {string} color - The color of the barrier.\n   */\n  constructor(x, y, width, height, angle, color) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.angle = angle;\n    this.color = color;\n    this.angularVelocity = 0;\n    this.friction = 0.1;\n    this.momentOfInertia = (width * width + height * height) / 12;\n  }\n\n  /**\n   * Draws the barrier on the canvas.\n   */\n  draw() {\n    ctx.save();\n    ctx.translate(this.x + this.width / 2, this.y + this.height / 2);\n    ctx.rotate(this.angle * Math.PI / 180);\n    ctx.fillStyle = this.color;\n    ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);\n    ctx.restore();\n  }\n\n  /**\n   * Checks if a ball is colliding with the barrier.\n   * @param {number} bx - The x-coordinate of the ball.\n   * @param {number} by - The y-coordinate of the ball.\n   * @param {number} br - The radius of the ball.\n   * @return {object} An object containing the normal vector, collision status, and contact point.\n   */\n  checkCollision(bx, by, br) {\n    const cos = Math.cos(-this.angle * Math.PI / 180);\n    const sin = Math.sin(-this.angle * Math.PI / 180);\n    const dx = bx - (this.x + this.width / 2);\n    const dy = by - (this.y + this.height / 2);\n    const localX = cos * dx - sin * dy + this.width / 2;\n    const localY = sin * dx + cos * dy + this.height / 2;\n\n    const closestX = Math.max(0, Math.min(this.width, localX));\n    const closestY = Math.max(0, Math.min(this.height, localY));\n\n    const distanceX = localX - closestX;\n    const distanceY = localY - closestY;\n    const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);\n\n    const isColliding = distance < br;\n    const normalX = distance !== 0 ? (cos * distanceX / distance + sin * distanceY / distance) : 0;\n    const normalY = distance !== 0 ? (-sin * distanceX / distance + cos * distanceY / distance) : 0;\n\n    const contactX = cos * closestX - sin * closestY + this.x;\n    const contactY = sin * closestX + cos * closestY + this.y;\n\n    return {normalX, normalY, isColliding, contactPoint: {x: contactX, y: contactY}};\n  }\n\n  /**\n   * Applies torque to the barrier.\n   * @param {number} force - The force applied to the barrier.\n   * @param {object} contactPoint - The point where the force is applied.\n   */\n  applyTorque(force, contactPoint) {\n    const dx = contactPoint.x - (this.x + this.width / 2);\n    const dy = contactPoint.y - (this.y + this.height / 2);\n    const torque = force * (dx * Math.sin(this.angle * Math.PI / 180) - dy * Math.cos(this.angle * Math.PI / 180));\n    this.angularVelocity += torque / this.momentOfInertia;\n  }\n\n  /**\n   * Updates the barrier's angle and angular velocity.\n   */\n  update() {\n    this.angle += this.angularVelocity;\n    this.angularVelocity *= 0.98;\n  }\n}\n\n/**\n * Generates a random color.\n * @return {string} A random color in hexadecimal format.\n */\nfunction getRandomColor() {\n  const letters = '0123456789ABCDEF';\n  let color = '#';\n  for (let i = 0; i < 6; i++) {\n    color += letters[Math.floor(Math.random() * 16)];\n  }\n  return color;\n}\n\n// Create balls and barriers\nfor (let i = 0; i < 100; i++) {\n  const radius = MAX_RADIUS;\n  const x = Math.random() * (canvas.width - radius * 2) + radius;\n  const y = Math.random() * 100 + radius;\n  const color = 'blue';\n  balls.push(new Ball(x, y, radius, color));\n}\n\nbarriers.push(new Barrier(100, 500, 150, 20, -20, 'black'));\nbarriers.push(new Barrier(600, 400, 150, 20, -20, 'black'));\nbarriers.push(new Barrier(200, 200, 100, 20, 45, 'black'));\nbarriers.push(new Barrier(400, 150, 120, 20, -45, 'black'));\nbarriers.push(new Barrier(500, 500, 200, 20, 15, 'black'));\nbarriers.push(new Barrier(800, 300, 150, 20, -15, 'black'));\n\n// Animate the simulation\nfunction animate() {\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  balls.forEach((ball) => ball.update());\n  barriers.forEach((barrier) => {\n    barrier.update();\n    barrier.draw();\n  });\n  requestAnimationFrame(animate);\n}\n\nanimate();"
    }
  ]
}
